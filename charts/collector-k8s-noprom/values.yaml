collectors:
  # collect kubelet stats from each node
  - name: kubelet-stats
    image: otel/opentelemetry-collector-contrib:0.83.0
    enabled: true
    mode: daemonset
    resources:
      limits:
        cpu: 500m
        memory: 500Mi
      requests:
        cpu: 128m
        memory: 128M
    env:
      - name: LS_TOKEN
        valueFrom:
          secretKeyRef:
            key: LS_TOKEN
            name: otel-collector-secret
    config:
      receivers:
        prometheus:
          config:
            scrape_configs:
            - job_name: otel-collector
              scrape_interval: 5s
              static_configs:
              - labels:
                  collector_name: ${KUBE_POD_NAME}
                targets:
                  - 0.0.0.0:8888
        kubeletstats:
          collection_interval: 10s
          auth_type: "serviceAccount"
          endpoint: "https://${K8S_NODE_NAME}:10250"
          insecure_skip_verify: true
          metric_groups:
            - node
            - pod
            - container
      processors:
        resourcedetection/env:
          detectors: [env]
          timeout: 2s
          override: false
        k8sattributes:
          filter:
            node_from_env_var: K8S_NODE_NAME
          pod_association:
            - sources:
                - from: resource_attribute
                  name: k8s.pod.name
          extract:
            labels:
            - tag_name: service.name
              key: app.kubernetes.io/name
              from: pod
            - tag_name: k8s.app.instance
              key: app.kubernetes.io/instance
              from: pod
            - tag_name: service.version
              key: app.kubernetes.io/version
              from: pod
            - tag_name: k8s.app.component
              key: app.kubernetes.io/component
              from: pod
            metadata:
              - k8s.deployment.name
              - k8s.replicaset.name
              - k8s.replicaset.uid
              - k8s.daemonset.name
              - k8s.daemonset.uid
              - k8s.job.name
              - k8s.job.uid
              - k8s.cronjob.name
              - k8s.statefulset.name
              - k8s.statefulset.uid
              - k8s.cluster.uid
        memory_limiter:
          check_interval: 1s
          limit_mib: 2000
        batch:
          send_batch_size: 1000
          timeout: 1s
          send_batch_max_size: 1500

      exporters:
        logging:
          verbosity: normal
          sampling_initial: 5
          sampling_thereafter: 200
        otlp:
          endpoint: ingest.lightstep.com:443
          headers:
            "lightstep-access-token": "${LS_TOKEN}"

      service:
        pipelines:
          metrics/collector:
            receivers: [prometheus]
            processors: [memory_limiter, batch]
            exporters: [otlp]
          metrics/kubelet:
            receivers: [kubeletstats]
            processors: [memory_limiter, resourcedetection/env, k8sattributes, batch]
            exporters: [logging, otlp]

  # collect cluster-level metrics
  - name: cluster-stats
    image: otel/opentelemetry-collector-contrib:0.83.0
    replicas: 1
    enabled: true
    resources:
      limits:
        cpu: 500m
        memory: 500Mi
      requests:
        cpu: 500m
        memory: 500Mi
    env:
      - name: LS_TOKEN
        valueFrom:
          secretKeyRef:
            key: LS_TOKEN
            name: otel-collector-secret
    config:
      receivers:
        # Prometheus receiver used for reporting collector health metrics
        # TODO: replace with OTLP metrics when merged
        prometheus:
          config:
            scrape_configs:
            - job_name: otel-collector
              scrape_interval: 5s
              static_configs:
              - labels:
                  collector_name: ${KUBE_POD_NAME}
                targets:
                  - 0.0.0.0:8888
        k8s_cluster:
          auth_type: serviceAccount
          collection_interval: 10s
          node_conditions_to_report: [Ready, MemoryPressure, DiskPressure, NetworkUnavailable]
          allocatable_types_to_report: [cpu, memory, storage]
        k8s_events:
          auth_type: serviceAccount

      processors:
        k8sattributes:
          extract:
            metadata:
              - k8s.cluster.uid
        resourcedetection/env:
          detectors: [env]
          timeout: 2s
          override: false
        memory_limiter:
          check_interval: 1s
          limit_percentage: 75
          spike_limit_percentage: 30
        batch:
          send_batch_size: 1000
          timeout: 1s
          send_batch_max_size: 1500

      exporters:
        logging:
          verbosity: normal
          sampling_initial: 5
          sampling_thereafter: 200
        otlp:
          endpoint: ingest.lightstep.com:443
          headers:
            "lightstep-access-token": "${LS_TOKEN}"

      service:
        pipelines:
          metrics/collector:
            receivers: [prometheus]
            processors: [memory_limiter, batch]
            exporters: [otlp]
          metrics/k8s_cluster:
            receivers: [k8s_cluster]
            processors: [memory_limiter, resourcedetection/env, k8sattributes, batch]
            exporters: [otlp, logging]
